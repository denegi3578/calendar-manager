import React, { useState, useEffect, useMemo, useRef } from "react";
import { auth, db } from './firebase'; // ìš°ë¦¬ê°€ ë§Œë“  ì„¤ì • íŒŒì¼
// ğŸ‘‡ ì—¬ê¸°ê°€ í•µì‹¬: ìµœì‹  ë„êµ¬ë“¤ì„ ê°€ì ¸ì˜µë‹ˆë‹¤
import { onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "firebase/auth";
import { doc, getDoc, setDoc } from "firebase/firestore";

/* ===== ë‚ ì§œ/ìœ í‹¸ ===== */
const pad = (n) => String(n).padStart(2, "0");
const toYMD = (d) => `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
const isYMD = (s) => /^\d{4}-\d{2}-\d{2}$/.test(s || "");
const parseYMD = (s) => { if (!s) return null; const [y,m,d]=s.split("-").map(Number); return new Date(y,m-1,d); };
const weekdayNames = ["ì¼","ì›”","í™”","ìˆ˜","ëª©","ê¸ˆ","í† "];
function buildMonthMatrix(year, month) {
  const first = new Date(year, month, 1);
  const startDay = first.getDay();
  const start = new Date(year, month, 1 - startDay);
  const cells = [];
  for (let i = 0; i < 42; i++) { const d = new Date(start); d.setDate(start.getDate() + i); cells.push(d); }
  return cells;
}
const isHHMM = (s) => /^\d{2}:\d{2}$/.test(s||"");
const addMin = (hhmm, m) => {
  if (!isHHMM(hhmm)) return null;
  let h = +hhmm.slice(0,2), mm = +hhmm.slice(3);
  let tot = h*60 + mm + m;
  if (tot < 0) tot = 0;
  if (tot > 24*60) tot = 24*60;
  const nh = Math.floor(tot/60), nmm = tot%60;
  return `${pad(nh)}:${pad(nmm)}`;
};
const UND = "_undated";
const FAIL_LIST = "ëª»í•¨";
const makeId = (p="t") => `${p}_${Date.now()}_${Math.random().toString(36).slice(2,7)}`;
const todayYMD = () => toYMD(new Date());
const WEEKDAY_MAP = { "ì¼":0,"ì›”":1,"í™”":2,"ìˆ˜":3,"ëª©":4,"ê¸ˆ":5,"í† ":6 };
function ymdAddDays(ymd, n){
  const d = parseYMD(ymd); d.setDate(d.getDate()+n); return toYMD(d);
}

// ë°˜ë³µ ê·œì¹™ ë³€ê²½ ê°ì§€ìš© ì‹œê·¸ë‹ˆì²˜
const recSignature = (recs = []) => {
  const slim = (recs || []).map(r => ({
    id: r.id,
    list: r.list,
    text: r.text,
    byweekday: (r.byweekday || [])
      .slice()
      .map(n => Number(n))
      .filter(Number.isFinite)
      .sort((a, b) => a - b),
    time: r.time || "",
    start: r.start || "",
    end: r.end || ""
  }));
  slim.sort((a, b) => (a.id || "").localeCompare(b.id || ""));
  return JSON.stringify(slim);
};

/* íŒ”ë ˆíŠ¸ */
const PALETTE = ["#ef4444","#f97316","#eab308","#22c55e","#06b6d4","#3b82f6","#6366f1","#a855f7","#ec4899","#14b8a6"];
const FAIL_COLOR = "#9ca3af";

/* ===== ì•± ===== */
export default function App() {
  const today = useMemo(() => new Date(), []);
    const [dayTick, setDayTick] = useState(todayYMD());
    useEffect(() => {
      const h = setInterval(() => {
        const k = todayYMD();
        setDayTick(prev => (prev === k ? prev : k));
      }, 60 * 1000);
      return () => clearInterval(h);
    }, []);
  const [viewYear, setViewYear] = useState(today.getFullYear());
  const [viewMonth, setViewMonth] = useState(today.getMonth());
  const [selectedDate, setSelectedDate] = useState(toYMD(today));
  const [newListName, setNewListName] = useState("");
  const [inputs, setInputs] = useState({});
  const [showTrash, setShowTrash] = useState(false);
  const [showFailed, setShowFailed] = useState(false); // ëª»í•¨ íŒ¨ë„
  const [showDone, setShowDone] = useState(false);     // ì™„ë£Œ íŒ¨ë„
  const [showPlan, setShowPlan] = useState(false);
  const [openTaskIds, setOpenTaskIds] = useState({});  // â‹¯ í¼ì¹¨ ìƒíƒœ
  const [quickAddModal, setQuickAddModal] = useState(false); // ë¹ ë¥¸ ì¶”ê°€ ëª¨ë‹¬
  const [recurringModal, setRecurringModal] = useState(false); // ë°˜ë³µ ì¶”ê°€ ëª¨ë‹¬
  
  // ğŸ”¥ Firebase ì¸ì¦ ìƒíƒœ
  const [user, setUser] = useState(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [syncStatus, setSyncStatus] = useState('synced'); // 'syncing', 'synced', 'offline'

  // ìŠ¤í† ì–´ ì´ˆê¸°í™” ë¡œì§ (ê¸°ì¡´ ìœ ì§€)
  const [store, setStore] = useState(() => {
    try {
      const raw = localStorage.getItem("ct-store-v11");
      if (raw) {
        const s = JSON.parse(raw);
        return {
          ...s,
          lists: {
            order: (s.lists?.order || []).filter(l => l !== FAIL_LIST), // FAIL_LIST ë¬¸ìì—´ë¡œ ì²˜ë¦¬í•˜ê±°ë‚˜ ìƒìˆ˜ê°€ ìˆë‹¤ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            colors: { ...(s.lists?.colors || {}) }
          },
          plan: s.plan || {},
          planRecurring: s.planRecurring || [],
          recDeleted: s.recDeleted || {}
        };
      }
      // v10 ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§ ë“±ì€ ê¸¸ì–´ì„œ ìƒëµí–ˆì§€ë§Œ, í•„ìš”í•˜ë©´ ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ ë‘ì…”ë„ ë©ë‹ˆë‹¤.
    } catch {}
    // ê¸°ë³¸ê°’ ë°˜í™˜
    return {
      lists:{ order:["ì¼ë°˜"], colors:{ "ì¼ë°˜": "#FF5733" } }, // PALETTE ë“±ì€ ê¸°ì¡´ ìƒìˆ˜ë¥¼ ì“°ì„¸ìš”
      dates:{},
      recurring:[],
      recDone:{},
      recDeleted:{},
      alarms:{},
      trash:[],
      meta:{ lastFailedSweep:"" },
      plan:{},
      planRecurring:[]
    };
  });

  useEffect(()=>localStorage.setItem("ct-store-v11", JSON.stringify(store)),[store]);

  /* ğŸ”¥ Firebase ì¸ì¦ ë¦¬ìŠ¤ë„ˆ (ìµœì‹  ë²„ì „ìœ¼ë¡œ ìˆ˜ì •ë¨) */
  useEffect(() => {
    if (!auth) {
      setAuthLoading(false);
      return;
    }
    
    // auth.onAuthStateChanged -> onAuthStateChanged(auth, ...) ë¡œ ë³€ê²½
    const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
      setUser(firebaseUser);
      setAuthLoading(false);
      
      if (firebaseUser) {
        console.log('âœ… ë¡œê·¸ì¸:', firebaseUser.email);
        loadFromFirestore(firebaseUser.uid);
      } else {
        console.log('âŒ ë¡œê·¸ì•„ì›ƒ');
      }
    });
    
    return () => unsubscribe();
  }, []);

  /* ğŸ”¥ Firestoreì—ì„œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸° (ìµœì‹  ë²„ì „ìœ¼ë¡œ ìˆ˜ì •ë¨) */
  const loadFromFirestore = async (userId) => {
    if (!db) return;
    
    try {
      setSyncStatus('syncing');
      
      // db.collection().doc() -> doc(db, ...) ë¡œ ë³€ê²½
      const docRef = doc(db, 'users', userId);
      const docSnap = await getDoc(docRef);
      
      if (docSnap.exists()) {
        const data = docSnap.data();
        console.log('ğŸ“¥ Firestoreì—ì„œ ë°ì´í„° ë¡œë“œ:', data);
        setStore(prev => ({
          ...prev,
          ...data,
          lists: {
            order: (data.lists?.order || prev.lists.order).filter(l => l !== FAIL_LIST),
            colors: { ...(prev.lists.colors || {}), ...(data.lists?.colors || {}) }
          }
        }));
      } else {
        await saveToFirestore(userId, store);
      }
      setSyncStatus('synced');
    } catch (error) {
      console.error('âŒ Firestore ë¡œë“œ ì‹¤íŒ¨:', error);
      setSyncStatus('offline');
    }
  };

  /* ğŸ”¥ Firestoreì— ë°ì´í„° ì €ì¥ (ìµœì‹  ë²„ì „ìœ¼ë¡œ ìˆ˜ì •ë¨) */
  const saveToFirestore = async (userId, data) => {
    if (!db || !userId) return;
    
    try {
      setSyncStatus('syncing');
      
      // db.collection().doc().set() -> setDoc() ìœ¼ë¡œ ë³€ê²½
      const docRef = doc(db, 'users', userId);
      await setDoc(docRef, data, { merge: true });
      
      console.log('ğŸ“¤ Firestoreì— ì €ì¥ ì™„ë£Œ');
      setSyncStatus('synced');
    } catch (error) {
      console.error('âŒ Firestore ì €ì¥ ì‹¤íŒ¨:', error);
      setSyncStatus('offline');
    }
  };

  /* ğŸ”¥ store ë³€ê²½ ì‹œ ìë™ ë™ê¸°í™” (ê¸°ì¡´ ìœ ì§€) */
  useEffect(() => {
    if (user && store) {
      const timeoutId = setTimeout(() => {
        saveToFirestore(user.uid, store);
      }, 1000); 
      return () => clearTimeout(timeoutId);
    }
  }, [store, user]);

  /* ğŸ”¥ Google ë¡œê·¸ì¸ (ìµœì‹  ë²„ì „ìœ¼ë¡œ ìˆ˜ì •ë¨) */
  const signInWithGoogle = async () => {
    try {
      // new firebase.auth.GoogleAuthProvider() -> new GoogleAuthProvider() ë¡œ ë³€ê²½
      const provider = new GoogleAuthProvider();
      // auth.signInWithPopup -> signInWithPopup(auth, provider) ë¡œ ë³€ê²½
      await signInWithPopup(auth, provider);
    } catch (error) {
      console.error('ë¡œê·¸ì¸ ì‹¤íŒ¨:', error);
      alert('ë¡œê·¸ì¸ ì‹¤íŒ¨: ' + error.message);
    }
  };

  /* ğŸ”¥ ë¡œê·¸ì•„ì›ƒ (ìµœì‹  ë²„ì „ìœ¼ë¡œ ìˆ˜ì •ë¨) */
  const signOutUser = async () => { // í•¨ìˆ˜ ì´ë¦„ ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•´ User ë¶™ì„
    try {
      // auth.signOut() -> signOut(auth) ë¡œ ë³€ê²½
      await signOut(auth);
      alert('ë¡œê·¸ì•„ì›ƒ ë˜ì—ˆìŠµë‹ˆë‹¤');
    } catch (error) {
      console.error('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨:', error);
    }
  };

  /* í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ */
  useEffect(() => {
    const handleKeyboard = (e) => {
      // Cmd(Mac) ë˜ëŠ” Ctrl(Windows/Linux)
      const isMod = e.metaKey || e.ctrlKey;
      
      // Cmd/Ctrl + K: ë¹ ë¥¸ ì¶”ê°€
      if (isMod && e.key === 'k') {
        e.preventDefault();
        setQuickAddModal(true);
      }
      
      // Cmd/Ctrl + F: ê²€ìƒ‰ (ë‚˜ì¤‘ì— êµ¬í˜„)
      if (isMod && e.key === 'f') {
        e.preventDefault();
        // TODO: ê²€ìƒ‰ ê¸°ëŠ¥
        alert('ê²€ìƒ‰ ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤');
      }
      
      // Escape: ëª¨ë‹¬/íŒ¨ë„ ë‹«ê¸°
      if (e.key === 'Escape') {
        setQuickAddModal(false);
        setRecurringModal(false);
        setShowTrash(false);
        setShowFailed(false);
        setShowDone(false);
      }
      
      // Cmd/Ctrl + 1~9: ëª©ë¡ ë¹ ë¥¸ ì„ íƒ (ë‚˜ì¤‘ì— êµ¬í˜„)
      if (isMod && e.key >= '1' && e.key <= '9') {
        e.preventDefault();
        const idx = parseInt(e.key) - 1;
        if (idx < store.lists.order.length) {
          // TODO: í•´ë‹¹ ëª©ë¡ìœ¼ë¡œ ìŠ¤í¬ë¡¤
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyboard);
    return () => window.removeEventListener('keydown', handleKeyboard);
  }, [store.lists.order]);

  

  /* 1íšŒì„±: FAIL ìƒ‰ë§Œ ë³´ì¥, orderì—” ì ˆëŒ€ ì•ˆ ë„£ìŒ */
  useEffect(() => {
    const hasFailColor = !!store?.lists?.colors?.[FAIL_LIST];
    if (!hasFailColor || store?.lists?.order?.includes(FAIL_LIST)) {
      setStore(p => ({
        ...p,
        lists: {
          order: (p.lists.order || []).filter(l => l !== FAIL_LIST),
          colors: { ...(p.lists.colors || {}), [FAIL_LIST]: p.lists.colors?.[FAIL_LIST] || FAIL_COLOR }
        }
      }));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  /* ì•Œë¦¼(Notification API) */
  const alarmTimersRef = useRef({});
  useEffect(()=>{ if("Notification" in window && Notification.permission==="default"){ Notification.requestPermission(); }},[]);
  useEffect(()=>{
    Object.values(alarmTimersRef.current).forEach(clearTimeout);
    alarmTimersRef.current = {};
    const now=Date.now(), limit=now+24*3600*1000;
    for(const [tid,when] of Object.entries(store.alarms||{})){
      const t=+when; if(!Number.isFinite(t) || t<=now || t>limit) continue;
      alarmTimersRef.current[tid]=setTimeout(()=>{
        if("Notification" in window && Notification.permission==="granted"){
          const info=findTaskById(tid);
          new Notification(info? `${info.list} Â· ${info.task.text}`:"í•  ì¼ ì•Œë¦¼",{ body: info?.key && info.key!==UND ? `ë‚ ì§œ: ${info.key}`:"ë¯¸ì§€ì •" });
        } else alert("í•  ì¼ ì•Œë¦¼ ì‹œê°„ì…ë‹ˆë‹¤!");
      }, t-now);
    }
    return ()=>Object.values(alarmTimersRef.current).forEach(clearTimeout);
  },[store.alarms]);

  const scheduleAlarm=(list,id,key,dateStr,timeStr)=>{
    if(!timeStr || !/^\d{2}:\d{2}$/.test(timeStr)){ alert("ì‹œê°„(HH:MM)ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”"); return; }
    let dt;
    if(key===UND || !isYMD(dateStr)){
      const base=new Date(); const [h,m]=timeStr.split(":").map(Number);
      dt=new Date(base.getFullYear(), base.getMonth(), base.getDate(), h, m, 0);
      if(dt.getTime()<Date.now()) dt=new Date(dt.getTime()+24*3600*1000);
    }else{
      const [y,m,d]=dateStr.split("-").map(Number); const [h,mm]=timeStr.split(":").map(Number);
      dt=new Date(y,m-1,d,h,mm,0);
    }
    if("Notification" in window && Notification.permission!=="granted") Notification.requestPermission();
    setStore(p=>({...p, alarms:{...(p.alarms||{}), [id]:dt.getTime()} }));
    alert("ì•ŒëŒ ì„¤ì • ì™„ë£Œ");
  };

  /* ë‹¬ë ¥ */
  const grid = useMemo(()=>buildMonthMatrix(viewYear, viewMonth),[viewYear,viewMonth]);
  const isTodayCell = (d)=> toYMD(d)===todayYMD();
  const isThisMonth = (d)=> d.getMonth()===viewMonth;
  const selectDate = (d)=> setSelectedDate(toYMD(d));
  const gotoPrevMonth = ()=>{ const m=new Date(viewYear,viewMonth-1,1); setViewYear(m.getFullYear()); setViewMonth(m.getMonth()); };
  const gotoNextMonth = ()=>{ const m=new Date(viewYear,viewMonth+1,1); setViewYear(m.getFullYear()); setViewMonth(m.getMonth()); };

  const quickAddAt = (ymd) => {
    const lists = store.lists.order; if (!lists.length) return;
    // ìµœê·¼ ì‚¬ìš© ëª©ë¡ ìš°ì„ , ì—†ìœ¼ë©´ ì²« ëª©ë¡
    const last = store.meta?.lastQuickList && lists.includes(store.meta.lastQuickList)
     ? store.meta.lastQuickList
      : lists[0];
    // ìˆ«ì/ì´ë¦„ ì•„ë¬´ê±°ë‚˜ ì…ë ¥ ë°›ì•„ì„œ ë§¤ì¹­
    const hint = lists.map((n,i)=>`${i+1}.${n}`).join(" / ");
    const raw = window.prompt(`ëª©ë¡ ì„ íƒ (ë²ˆí˜¸ ë˜ëŠ” ì´ë¦„)\n${hint}`, last);
    if (raw == null) return; // ì·¨ì†Œ
    const pick = raw.trim();
    let list = null;
    // 1) ìˆ«ì
    if (/^\d+$/.test(pick)) {
      const idx = Number(pick)-1;
      if (idx>=0 && idx<lists.length) list = lists[idx];
    }
    // 2) ì´ë¦„(ëŒ€ì†Œë¬¸ì/ê³µë°± ë¬´ì‹œ)
    if (!list) {
      const norm = (s)=>s.replace(/\s+/g,"").toLowerCase();
      list = lists.find(n => norm(n) === norm(pick));
    }
    if (!list) { alert("ëª©ë¡ ì¸ì‹ ì‹¤íŒ¨"); return; }

    const text = window.prompt(`${ymd}ì— ì¶”ê°€í•  í•  ì¼ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”`)?.trim();
    if (!text) return;
    ensureKey(ymd);
    const id = makeId("t");
    setStore(p=>{
      const d = p.dates[ymd] ?? { tasks:{} };
      const arr = d.tasks[list] ? [...d.tasks[list]] : [];
      arr.push({ id, text, done:false, deferCount:0, subtasks:[] });
      // ìµœê·¼ ì„ íƒ ì €ì¥
      const meta = { ...(p.meta||{}), lastQuickList: list };
      return { ...p, dates:{ ...p.dates, [ymd]: { tasks:{ ...d.tasks, [list]: arr } } }, meta };
    });
  };

  /* êµ¬ì¡° ë³´ì¡° */
  const ensureKey=(key)=> setStore(p=> p.dates[key]? p : ({...p, dates:{...p.dates,[key]:{tasks:{}}}}));
  const nextColor=()=>{ const used=Object.values(store.lists.colors||{}); return PALETTE[used.length%PALETTE.length]; };
  const colorOf=(name)=> store.lists.colors?.[name] || "#9ca3af";

  /* ëª©ë¡ ê´€ë¦¬ */
  const addList=()=>{
    const name=newListName.trim(); if(!name) return;
    if(name === FAIL_LIST){ alert("'ëª»í•¨'ì€ ì‹œìŠ¤í…œ ëª©ë¡ì…ë‹ˆë‹¤. ì´ë¦„ìœ¼ë¡œ ì“¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"); return; }
    if(store.lists.order.includes(name)){ alert("ì´ë¯¸ ìˆëŠ” ëª©ë¡ ì´ë¦„"); return; }
    setStore(p=>({...p, lists:{order:[...p.lists.order,name], colors:{...p.lists.colors,[name]:nextColor()}}}));
    setNewListName("");
  };
  const removeList=(name)=>{
    if(store.lists.order.length<=1){ alert("ìµœì†Œ 1ê°œ ëª©ë¡ì€ ë‚¨ê²¨ì•¼ í•©ë‹ˆë‹¤"); return; }
    if(name===FAIL_LIST){ alert("'ëª»í•¨'ì€ ì‹œìŠ¤í…œ ëª©ë¡ì…ë‹ˆë‹¤."); return; }
    if(!confirm(`'${name}' ëª©ë¡ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ëª¨ë“  ë‚ ì§œ/ë¯¸ì§€ì • í¬í•¨)`)) return;
    setStore(prev=>{
      const scrub=(obj)=>{ const out={}; for(const [k,v] of Object.entries(obj||{})){ const tasks=v.tasks||{};
        if(tasks[name]){ const {[name]:_,...rest}=tasks; out[k]={tasks:rest}; } else out[k]=v; }
        return out;
      };
      return {
        lists:{ order: prev.lists.order.filter(l=>l!==name),
                colors:Object.fromEntries(Object.entries(prev.lists.colors).filter(([k])=>k!==name)) },
        dates:scrub(prev.dates), recurring:(prev.recurring||[]).filter(r=>r.list!==name),
        recDone:prev.recDone, recDeleted:prev.recDeleted, alarms:prev.alarms, trash:prev.trash, meta: prev.meta
      };
    });
  };
  const setListColor=(name,color)=> {
    if (name === FAIL_LIST) return;
    setStore(p=>({...p, lists:{order:p.lists.order, colors:{...p.lists.colors,[name]:color}}}));
  };

  /* ì •ë ¬ ê¸°ì¤€: ê°€ê¹Œìš´ ë¯¸ë˜ ìš°ì„  â†’ ê³¼ê±°(ìµœê·¼ìˆœ) â†’ ë¯¸ì§€ì • */
  const allByList = useMemo(()=>{
    const out={}; store.lists.order.forEach(l=>out[l]=[]);
    const today0 = parseYMD(todayYMD()).getTime();

    for(const [key,obj] of Object.entries(store.dates||{})){
      for(const [list,arr] of Object.entries(obj.tasks||{})){
        if(list===FAIL_LIST) continue;
        (arr||[])
          .filter(t=>{
           // âœ… deleted í•­ëª© ì œì™¸ (ì¹´ë“œì—ëŠ” ì•ˆ ë³´ì´ê²Œ)
           if(t.deleted) return false;
           // ì™„ë£Œ ì•ˆ ëìœ¼ë©´ ë³´ì´ê¸°
          if(!t.done) return true;
          // ì™„ë£Œ + ë‚ ì§œ ì—†ìŒ(UND) â†’ ë°”ë¡œ ìˆ¨ê¹€
          if(key===UND) return false;
          // ì™„ë£Œ + ë‚ ì§œ ìˆìŒ â†’ ë‚ ì§œê°€ ì˜¤ëŠ˜/ë¯¸ë˜ë©´ ë³´ì´ê¸°, ê³¼ê±°ë©´ ìˆ¨ê¹€
          const at = parseYMD(key).getTime();
          return at >= today0;
        })
        .forEach(t=> out[list].push({...t, date:key===UND?null:key}));
      }
    }

    for(const list of Object.keys(out)){
      out[list].sort((a,b)=>{
        const aHas = !!a.date, bHas = !!b.date;
        if (aHas && bHas) {
          const at = parseYMD(a.date).getTime();
          const bt = parseYMD(b.date).getTime();
          const aFuture = at >= today0, bFuture = bt >= today0;
          if (aFuture !== bFuture) return aFuture ? -1 : 1; // ë¯¸ë˜ê°€ ë¨¼ì €
          if (aFuture && bFuture) {
            if (at !== bt) return at - bt; // ê°€ê¹Œìš´ ë¯¸ë˜ ë¨¼ì €
            const ta=a.time||"", tb=b.time||""; if(ta!==tb) return ta.localeCompare(tb);
          } else { // ë‘˜ ë‹¤ ê³¼ê±°ë©´ ìµœê·¼(ëœ ì§€ë‚œ) ë¨¼ì €
            if (at !== bt) return bt - at;
            const ta=a.time||"", tb=b.time||""; if(ta!==tb) return tb.localeCompare(ta);
          }
          const ar=a.rank??0, br=b.rank??0; if(ar!==br) return ar-br;
          return a.id.localeCompare(b.id);
        } else if (aHas !== bHas) {
          return aHas ? -1 : 1; // ë‚ ì§œ ìˆëŠ” ê²Œ ë¨¼ì €
        } else {
          // ë‘˜ ë‹¤ ë¯¸ì§€ì •: rank â†’ id
          const ar=a.rank??0, br=b.rank??0; if(ar!==br) return ar-br;
          return a.id.localeCompare(b.id);
        }
      });
    }
    return out;
  },[store]);

  /* ì…ë ¥/ì¶”ê°€ */
  const setInputFor=(list,key,value)=> setInputs(p=>({...p,[list]:{...(p[list]||{}),[key]:value}}));
  const addTaskGlobal=(list)=>{
    const text=(inputs[list]?.text||"").trim();
    const dateRaw=(inputs[list]?.date||"").trim();
    const timeRaw=(inputs[list]?.time||"").trim();
    if(!text) return;
    const key=isYMD(dateRaw)?dateRaw:UND; ensureKey(key);
    const id=makeId("t");
    setStore(p=>{
      const d=p.dates[key]??{tasks:{}}; const arr=d.tasks[list]?[...d.tasks[list]]:[];
      arr.push({ id, text, done:false, time:timeRaw||undefined, star:false,
        priority:"mid", estimateMin:undefined, details:"", deferCount:0, subtasks:[], sessions:[] });
      return {...p, dates:{...p.dates,[key]:{tasks:{...d.tasks,[list]:arr}}}};
    });
    setInputs(p=>({...p,[list]:{text:"", date:isYMD(dateRaw)?dateRaw:"", time:""}}));
  };

  /* ê°±ì‹  ê³µí†µ */
  function findTaskById(taskId, snapshot=store){
    for(const [key,obj] of Object.entries(snapshot.dates||{})){
      for(const [list,arr] of Object.entries(obj.tasks||{})){
        const idx=(arr||[]).findIndex(t=>t.id===taskId);
        if(idx>=0) return {key,list,idx,task:arr[idx]};
      }
    }
    return null;
  }
  const updateTask=(list,id,key,fn)=>{
    const k=key||UND;
    setStore(p=>{
      const d=p.dates[k]; if(!d) return p;
      const arr=[...(d.tasks[list]||[])];
      const i=arr.findIndex(t=>t.id===id); if(i<0) return p;
      arr[i]=fn({...arr[i]});
      return {...p, dates:{...p.dates,[k]:{tasks:{...d.tasks,[list]:arr}}}};
    });
  };
  const toggleStar=(list,id,date)=>updateTask(list,id,date||UND,t=>({...t,star:!t.star}));
  const saveDetails=(list,id,key,fields)=>updateTask(list,id,key||UND,t=>({...t,...fields}));

  const toggleDone = (list, id, date) =>
    updateTask(list, id, date || UND, t => {
      const nd = !t.done;
      const subs = (t.subtasks || []).map(s => ({ ...s, done: nd ? true : s.done }));
      return { ...t, done: nd, subtasks: subs };
    });

  /* ì„œë¸Œí…ŒìŠ¤í¬ ì¡°ì‘ */
  const addSubtask = (list, id, date, text) =>
    updateTask(list, id, date || UND, t => {
      const subs = (t.subtasks || []).slice();
      subs.push({ id: makeId("sub"), text, done:false });
      return { ...t, subtasks: subs };
    });
  const toggleSubtask = (parentList, parentId, date, subId) =>
    updateTask(parentList, parentId, date || UND, t => {
      const subs = (t.subtasks || []).map(s => s.id===subId ? ({...s, done:!s.done}) : s);
      const allDone = subs.length>0 && subs.every(s=>s.done);
      return { ...t, subtasks: subs, done: allDone ? true : t.done };
    });
  const editSubtaskText = (parentList, parentId, date, subId, text) =>
    updateTask(parentList, parentId, date || UND, t => {
      const subs = (t.subtasks || []).map(s => s.id===subId ? ({...s, text}) : s);
      return { ...t, subtasks: subs };
    });
  const removeSubtask = (parentList, parentId, date, subId) =>
    updateTask(parentList, parentId, date || UND, t => {
      const subs = (t.subtasks || []).filter(s => s.id!==subId);
      return { ...t, subtasks: subs };
    });

  /* íœ´ì§€í†µ */
  const removeTask=(list,id,date)=>{
    const key=date||UND;
    
    // âœ… ë°˜ë³µ í•­ëª©ì¸ì§€ í™•ì¸
    const isRecurring = id && id.startsWith('rec_');
    
    if (isRecurring) {
      const choice = window.confirm(
        "ë°˜ë³µ í• ì¼ì…ë‹ˆë‹¤. ì–´ë–»ê²Œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\n" +
        "í™•ì¸ = ì´ë²ˆë§Œ ì‚­ì œ (ë‹¤ë¥¸ ë‚ ì§œëŠ” ê³„ì† ìƒì„±)\n" +
        "ì·¨ì†Œ = ë°˜ë³µ ì¤‘ë‹¨ (ì˜¤ëŠ˜ë¶€í„° ì•ìœ¼ë¡œ ì­‰ ì‚­ì œ)"
      );
      
      if (choice) {
        // "ì´ë²ˆë§Œ ì‚­ì œ" ì„ íƒ - ë‹¬ë ¥ì—ëŠ” ë‚¨ê¸°ë˜ deleted í‘œì‹œ
        setStore(p=>{
          const d=p.dates[key]; if(!d) return p;
          const arr=[...(d.tasks[list]||[])];
          const i=arr.findIndex(t=>t.id===id);
          if(i<0) return p;
          
          // âœ… ë°°ì—´ì—ì„œ ì œê±°í•˜ì§€ ì•Šê³  deleted í”Œë˜ê·¸ë§Œ ì¶”ê°€
          arr[i] = { ...arr[i], deleted: true, deletedAt: Date.now() };
          
          // ì‚­ì œ ê¸°ë¡ ë‚¨ê¸°ê¸° (ì¬ìƒì„± ë°©ì§€)
          let newRecDeleted = { ...(p.recDeleted || {}) };
          const match = id.match(/^rec_(.+)_(\d{4}-\d{2}-\d{2})$/);
          if (match) {
            const [, recId, ymd] = match;
            const deleteKey = `${recId}@${ymd}`;
            newRecDeleted[deleteKey] = true;
          }
          
          return {...p,
            dates:{...p.dates,[key]:{tasks:{...d.tasks,[list]:arr}}},
            recDeleted: newRecDeleted
          };
        });
      } else {
        // "ë°˜ë³µ ì¤‘ë‹¨" ì„ íƒ
        const match = id.match(/^rec_(.+)_(\d{4}-\d{2}-\d{2})$/);
        if (match) {
          const [, recId] = match;
          const today = parseYMD(todayYMD());
          
          setStore(p=>{
            const d=p.dates[key]; if(!d) return p;
            const arr=[...(d.tasks[list]||[])];
            const i=arr.findIndex(t=>t.id===id);
            if(i<0) return p;
            
            // âœ… ì´ê²ƒë„ deleted í”Œë˜ê·¸ë§Œ ì¶”ê°€
            arr[i] = { ...arr[i], deleted: true, deletedAt: Date.now() };
            
            // í•´ë‹¹ ë°˜ë³µ ê·œì¹™ì˜ ì¢…ë£Œì¼ì„ ì–´ì œë¡œ ì„¤ì •
            const updatedRecurring = (p.recurring || []).map(r => {
              if (r.id === recId) {
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                return { ...r, end: toYMD(yesterday) };
              }
              return r;
            });
            
            return {...p,
              dates:{...p.dates,[key]:{tasks:{...d.tasks,[list]:arr}}},
              recurring: updatedRecurring
            };
          });
          
          alert("ë°˜ë³µì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. (ì˜¤ëŠ˜ë¶€í„° ë” ì´ìƒ ìƒì„±ë˜ì§€ ì•ŠìŒ)");
        }
      }
    } else {
      // ì¼ë°˜ í• ì¼ ì‚­ì œ (ê¸°ì¡´ ë¡œì§)
      setStore(p=>{
        const d=p.dates[key]; if(!d) return p;
        const arr=[...(d.tasks[list]||[])];
        const i=arr.findIndex(t=>t.id===id);
        if(i<0) return p;
        const removed=arr.splice(i,1)[0];
        
        return {...p,
          dates:{...p.dates,[key]:{tasks:{...d.tasks,[list]:arr}}},
          trash:[{id:removed.id,list,key,task:removed,deletedAt:Date.now()}, ...(p.trash||[])].slice(0,500)
        };
      });
    }
  };
  const restoreTrash=(tid)=>{
    const item=store.trash.find(x=>x.id===tid); if(!item) return;
    setStore(p=>{
      const rest=(p.trash||[]).filter(x=>x.id!==tid);
      const d=p.dates[item.key]??{tasks:{}}; const arr=d.tasks[item.list]?[...d.tasks[item.list]]:[];
      arr.push(item.task);
      
      // âœ… ë°˜ë³µ í• ì¼ì´ì—ˆë‹¤ë©´ ì‚­ì œ ê¸°ë¡ ì œê±°
      let newRecDeleted = { ...(p.recDeleted || {}) };
      if (item.task.id && item.task.id.startsWith('rec_')) {
        const match = item.task.id.match(/^rec_(.+)_(\d{4}-\d{2}-\d{2})$/);
        if (match) {
          const [, recId, ymd] = match;
          const deleteKey = `${recId}@${ymd}`;
          delete newRecDeleted[deleteKey];
        }
      }
      
      return {...p, trash:rest, dates:{...p.dates,[item.key]:{tasks:{...d.tasks,[item.list]:arr}}}, recDeleted: newRecDeleted};
    });
  };
  const deleteForever=(tid)=> setStore(p=>({...p, trash:(p.trash||[]).filter(x=>x.id!==tid)}));

  /* ë¯¸ë£¨ê¸° */
  const snoozeByDays=(list,id,date,days=1)=>{
    const srcKey=date||UND;
    let dst;
    if(srcKey===UND){
      const base=parseYMD(todayYMD()); base.setDate(base.getDate()+days); dst=toYMD(base);
    }else{
      const base=parseYMD(srcKey); base.setDate(base.getDate()+days); dst=toYMD(base);
    }
    ensureKey(dst);
    setStore(p=>{
      const from=p.dates[srcKey]; if(!from) return p;
      const arrF=[...(from.tasks[list]||[])];
      const idx=arrF.findIndex(t=>t.id===id); if(idx<0) return p;
      const item={...arrF[idx], deferCount:(arrF[idx].deferCount||0)+1};
      arrF.splice(idx,1);
      const to=p.dates[dst]??{tasks:{}}; const arrT=to.tasks[list]?[...to.tasks[list]]:[];
      arrT.push(item);
      return {...p, dates:{...p.dates, [srcKey]:{tasks:{...from.tasks,[list]:arrF}}, [dst]:{tasks:{...to.tasks,[list]:arrT}}}};
    });
  };

  /* 2ì¼ í›„ ìë™ 'ëª»í•¨' ì´ë™ (í•˜ë£¨ 1íšŒ) */
  useEffect(()=>{
    const todayKey = todayYMD();
    if (store.meta?.lastFailedSweep === todayKey) return;

    setStore(prev=>{
      const newDates = {...prev.dates};
      const twoDaysAgo = new Date();
      twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
      const twoDaysAgoKey = toYMD(twoDaysAgo);

      for (const [key, obj] of Object.entries(prev.dates || {})) {
        if (key === UND) continue;
        if (parseYMD(key).getTime() > parseYMD(twoDaysAgoKey).getTime()) continue;

        const tasksByList = obj.tasks || {};
        for (const [list, arr] of Object.entries(tasksByList)) {
          if (list===FAIL_LIST) continue;
          const remain = [];
          for (const t of (arr || [])) {
            if (!t.done) {
              const dstObj = newDates[key] ?? { tasks: {} };
              const failArr = (dstObj.tasks[FAIL_LIST] || []).slice();
              failArr.push({ ...t, failed: true, failedAt: Date.now() });
              dstObj.tasks = { ...dstObj.tasks, [FAIL_LIST]: failArr };
              newDates[key] = dstObj;
            } else {
              remain.push(t);
            }
          }
          newDates[key].tasks = { ...newDates[key].tasks, [list]: remain };
        }
      }

      return {
        ...prev,
        dates: newDates,
        meta: { ...(prev.meta || {}), lastFailedSweep: todayKey },
      };
    });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [store.meta?.lastFailedSweep]);

// âœ… ì¤‘ë³µ ìƒì„± ì™„ì „ ì°¨ë‹¨: ref + meta + localStorage + lock(+TTL)
const recSweepRef = useRef("");
useEffect(() => {
  const todayKey = todayYMD();
  const sig = recSignature(store.recurring);
  const guardKey = `${todayKey}::${sig}`;
  const LS_KEY = "ct_rec_sweep_key";
  const LOCK_KEY = "ct_rec_sweep_lock";
  const LOCK_TS_KEY = "ct_rec_sweep_lock_ts";
  const LOCK_STALE_MS = 120 * 1000;

  if (recSweepRef.current === guardKey) return;
  if (store.meta?.recSweepKey === guardKey) return;
  try {
    const done = localStorage.getItem(LS_KEY);
    if (done === guardKey) return;

    const locked = localStorage.getItem(LOCK_KEY);
    const lts = Number(localStorage.getItem(LOCK_TS_KEY) || 0);
    const stale = Date.now() - lts > LOCK_STALE_MS;

    if (locked === guardKey && !stale) return;
    localStorage.setItem(LOCK_KEY, guardKey);
    localStorage.setItem(LOCK_TS_KEY, String(Date.now()));
  } catch {}

  recSweepRef.current = guardKey;

  setStore(prev => {
    const recs = prev.recurring || [];

    if (!recs.length) {
      try {
        localStorage.setItem(LS_KEY, guardKey);
        localStorage.removeItem(LOCK_KEY);
        localStorage.removeItem(LOCK_TS_KEY);
      } catch {}
      return { ...prev, meta: { ...(prev.meta || {}), recSweepKey: guardKey } };
    }

    const start = todayKey;
    const horizon = ymdAddDays(start, 30);
    const todayDate = parseYMD(start);
    const horizonDate = parseYMD(horizon);

    const dates = { ...(prev.dates || {}) };
    const recDone = { ...(prev.recDone || {}) };
    const recDeleted = { ...(prev.recDeleted || {}) }; // âœ… ì‚­ì œ ê¸°ë¡ ì°¸ì¡°

    for (const r of recs) {
      const endDate = r.end ? parseYMD(r.end) : null;
      const rStart = r.start ? parseYMD(r.start) : todayDate;
      const base = rStart.getTime() < todayDate.getTime() ? todayDate : rStart;

      for (let d = new Date(base); d.getTime() <= horizonDate.getTime(); d.setDate(d.getDate() + 1)) {
        if (endDate && d.getTime() > endDate.getTime()) break;

        const weekdays = (r.byweekday || []).map(n => Number(n)).filter(Number.isFinite);
        if (!weekdays.includes(d.getDay())) continue;

        const ymd = toYMD(d);
        const doneKey = `${r.id}@${ymd}`;
        
        // âœ… ì‚­ì œëœ í•­ëª©ì´ë©´ ìƒì„±í•˜ì§€ ì•ŠìŒ
        if (recDeleted[doneKey]) continue;
        
        if (recDone[doneKey]) continue;

        const day = dates[ymd] || { tasks: {} };
        const arr = (day.tasks[r.list] || []).slice();
        const detId = `rec_${r.id}_${ymd}`;
        if (arr.some(t => t.id === detId)) {
          recDone[doneKey] = 1;
          continue;
        }
        arr.push({
          id: detId,
          text: r.text,
          done: false,
          time: r.time,
          star: false,
          priority: "mid",
          estimateMin: undefined,
          details: "",
          deferCount: 0,
          subtasks: [],
          sessions: []
        });
        day.tasks = { ...day.tasks, [r.list]: arr };
        dates[ymd] = day;
        recDone[doneKey] = 1;
      }
    }

    try {
      localStorage.setItem(LS_KEY, guardKey);
      localStorage.removeItem(LOCK_KEY);
      localStorage.removeItem(LOCK_TS_KEY);
    } catch {}

    return { ...prev, dates, recDone, meta: { ...(prev.meta || {}), recSweepKey: guardKey } };
  });

}, [store.recurring, dayTick]);

 useEffect(() => {
   if (store.meta?.recDetFixV1 === 'done') return;
   const todayKey = todayYMD();
   setStore(prev => {
     const recs = prev.recurring || [];
     if (!recs.length) {
       return { ...prev, meta:{ ...(prev.meta||{}), recDetFixV1:'done' } };
     }
     const newDates = { ...(prev.dates||{}) };
     const newAlarms = { ...(prev.alarms||{}) };
     const newRecDone = { ...(prev.recDone||{}) };

     const keys = Object.keys(newDates).filter(k => k !== UND && parseYMD(k) && parseYMD(k) <= parseYMD(todayKey));

     for (const r of recs) {
       for (const ymd of keys) {
         const day = newDates[ymd];
         if (!day?.tasks) continue;
         const arr = (day.tasks[r.list] || []).slice();
         if (!arr.length) continue;

         const detId = `rec_${r.id}_${ymd}`;
         const doneKey = `${r.id}@${ymd}`;

         const same = arr.filter(t => {
           if (t.text !== r.text) return false;
           if (r.time) return (t.time || "") === r.time;
           return true;
         });
         if (!same.length) continue;

         let keepId = same.find(t => t.id === detId)?.id;
         if (!keepId) {
           const first = same[0];
           keepId = detId;
           if (prev.alarms && prev.alarms[first.id]) {
             newAlarms[detId] = prev.alarms[first.id];
             delete newAlarms[first.id];
           }
           const idx = arr.findIndex(t => t.id === first.id);
           if (idx >= 0) arr[idx] = { ...arr[idx], id: detId };
         }
         const removeIds = new Set(same.filter(t => t.id !== keepId).map(t => t.id));
         const compact = arr.filter(t => !removeIds.has(t.id));

         day.tasks = { ...day.tasks, [r.list]: compact };
         newDates[ymd] = day;
         newRecDone[doneKey] = 1;
       }
     }

     return {
       ...prev,
       dates: newDates,
       alarms: newAlarms,
       recDone: newRecDone,
       meta:{ ...(prev.meta||{}), recDetFixV1:'done' }
     };
   });
 }, [store.recurring]);


  /* ë“œë˜ê·¸ */
  const dragRef=useRef(null);
  const onDragStart=(task)=>(e)=>{ dragRef.current=task; e.dataTransfer.effectAllowed="move"; };
  const onDragEnd=()=>{ dragRef.current=null; };
  const onDragOver=(e)=>e.preventDefault();
  const dropToList=(listTo)=>(e)=>{ e.preventDefault(); const task=dragRef.current; if(!task) return; moveInSameKey(task,listTo,null); };
  const dropBefore=(listTo,before)=>(e)=>{ e.preventDefault(); const task=dragRef.current; if(!task) return; moveInSameKey(task,listTo,before); };
  const moveInSameKey=(task,listTo,beforeTask)=>{
    const key=task.date?task.date:UND; const id=task.id;
    const listFrom=task._from || findTaskById(id)?.list; if(!listFrom) return;
    setStore(p=>{
      const d=p.dates[key]; if(!d) return p;
      const srcList = d.tasks[listFrom] || [];
      const srcItem = srcList.find(t=>t.id===id) || task;
      if (listFrom === listTo) {
       const arr = srcList.filter(t=>t.id!==id);
       const insertIdx = beforeTask ? Math.max(0, arr.findIndex(t=>t.id===beforeTask.id)) : arr.length;
       const item = {...srcItem};
       arr.splice(insertIdx < 0 ? arr.length : insertIdx, 0, item);
       arr.forEach((t,i)=> t.rank = i);
       return {...p, dates:{...p.dates, [key]:{tasks:{...d.tasks, [listFrom]: arr}}}};
     } else {
       const fromArr = srcList.filter(t=>t.id!==id);
       const toArr = (d.tasks[listTo] || []).slice();
       const item = {...srcItem};
       if (beforeTask) {
         const i = toArr.findIndex(t=>t.id===beforeTask.id);
         if(i<0) toArr.push(item); else toArr.splice(i,0,item);
         toArr.forEach((t,i2)=> t.rank=i2);
       } else {
         item.rank = toArr.length; toArr.push(item);
       }
       return {...p, dates:{...p.dates, [key]:{tasks:{...d.tasks, [listFrom]: fromArr, [listTo]: toArr}}}};
     }
    });
  };
const saveTopNote = (val) => {
  setStore(p => ({ ...p, meta: { ...(p.meta || {}), topNote: val } }));
};

  /* ë¹ ë¥¸ ì¶”ê°€ ëª¨ë‹¬ */
  const QuickAddModal = () => {
    const [text, setText] = useState('');
    const [list, setList] = useState(store.lists.order[0] || '');
    const [date, setDate] = useState(todayYMD());
    const [time, setTime] = useState('');
    const [dateMode, setDateMode] = useState('today'); // 'today', 'tomorrow', 'dayafter', 'custom'
    
    if (!quickAddModal) return null;
    
    // ë‚ ì§œ ëª¨ë“œì— ë”°ë¼ ì‹¤ì œ ë‚ ì§œ ê³„ì‚°
    const getActualDate = () => {
      const today = new Date();
      switch(dateMode) {
        case 'today': return todayYMD();
        case 'tomorrow': 
          today.setDate(today.getDate() + 1);
          return toYMD(today);
        case 'dayafter':
          today.setDate(today.getDate() + 2);
          return toYMD(today);
        case 'custom': return date;
        default: return todayYMD();
      }
    };
    
    const handleAdd = () => {
      if (!text.trim() || !list) return;
      const actualDate = getActualDate();
      const key = isYMD(actualDate) ? actualDate : UND;
      ensureKey(key);
      const id = makeId("t");
      setStore(p => {
        const d = p.dates[key] ?? { tasks: {} };
        const arr = d.tasks[list] ? [...d.tasks[list]] : [];
        arr.push({
          id, text: text.trim(), done: false, time: time || undefined, star: false,
          priority: "mid", estimateMin: undefined, details: "", deferCount: 0, subtasks: [], sessions: []
        });
        return { ...p, dates: { ...p.dates, [key]: { tasks: { ...d.tasks, [list]: arr } } } };
      });
      setText('');
      setTime('');
      setDateMode('today');
      setQuickAddModal(false);
    };
    
    return (
      <div style={S.modalOverlay} onClick={() => setQuickAddModal(false)}>
        <div style={S.modalContent} onClick={(e) => e.stopPropagation()}>
          <h3 style={{ margin: '0 0 16px' }}>ë¹ ë¥¸ ì¶”ê°€ (Cmd/Ctrl+K)</h3>
          
          <div style={{ display: 'grid', gap: 12 }}>
            <input
              autoFocus
              placeholder="í•  ì¼ ì…ë ¥..."
              value={text}
              onChange={(e) => setText(e.target.value)}
              onKeyDown={(e) => e.key === 'Enter' && handleAdd()}
              style={{ ...S.textInput, fontSize: 16 }}
            />
            
            <select
              value={list}
              onChange={(e) => setList(e.target.value)}
              style={S.textInput}
            >
              {store.lists.order.map(l => (
                <option key={l} value={l}>{l}</option>
              ))}
            </select>
            
            {/* ë‚ ì§œ ë¹ ë¥¸ ì„ íƒ ë²„íŠ¼ */}
            <div>
              <div style={{ fontSize: 13, color: '#6b7280', marginBottom: 6 }}>ë‚ ì§œ ì„ íƒ:</div>
              <div style={{ display: 'flex', gap: 6, flexWrap: 'wrap' }}>
                <button
                  onClick={() => setDateMode('today')}
                  style={{
                    ...S.toggleBtn,
                    ...(dateMode === 'today' ? S.toggleBtnActive : {})
                  }}
                >
                  ì˜¤ëŠ˜
                </button>
                <button
                  onClick={() => setDateMode('tomorrow')}
                  style={{
                    ...S.toggleBtn,
                    ...(dateMode === 'tomorrow' ? S.toggleBtnActive : {})
                  }}
                >
                  ë‚´ì¼
                </button>
                <button
                  onClick={() => setDateMode('dayafter')}
                  style={{
                    ...S.toggleBtn,
                    ...(dateMode === 'dayafter' ? S.toggleBtnActive : {})
                  }}
                >
                  ëª¨ë ˆ
                </button>
                <button
                  onClick={() => setDateMode('custom')}
                  style={{
                    ...S.toggleBtn,
                    ...(dateMode === 'custom' ? S.toggleBtnActive : {})
                  }}
                >
                  ì§ì ‘ ì„ íƒ
                </button>
              </div>
              {dateMode === 'custom' && (
                <input
                  type="date"
                  value={date}
                  onChange={(e) => setDate(e.target.value)}
                  style={{ ...S.dateInput, marginTop: 8 }}
                />
              )}
            </div>
            
            <input
              type="time"
              value={time}
              onChange={(e) => setTime(e.target.value)}
              placeholder="ì‹œê°„ (ì„ íƒ)"
              style={S.timeInput}
            />
            
            <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end', marginTop: 8 }}>
              <button onClick={() => setQuickAddModal(false)} style={S.secondaryBtn}>
                ì·¨ì†Œ (Esc)
              </button>
              <button onClick={handleAdd} style={S.primaryBtn}>
                ì¶”ê°€ (Enter)
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  /* ë°˜ë³µ ì¶”ê°€ ëª¨ë‹¬ */
  const RecurringModal = () => {
    const [text, setText] = useState('');
    const [list, setList] = useState(store.lists.order[0] || '');
    const [time, setTime] = useState('');
    const [weekdays, setWeekdays] = useState([]); // [0,1,2,3,4,5,6]
    const [startDate, setStartDate] = useState(todayYMD());
    const [endDate, setEndDate] = useState('');
    
    if (!recurringModal) return null;
    
    const weekdayButtons = [
      { label: 'ì¼', value: 0 },
      { label: 'ì›”', value: 1 },
      { label: 'í™”', value: 2 },
      { label: 'ìˆ˜', value: 3 },
      { label: 'ëª©', value: 4 },
      { label: 'ê¸ˆ', value: 5 },
      { label: 'í† ', value: 6 }
    ];
    
    const toggleWeekday = (day) => {
      setWeekdays(prev => 
        prev.includes(day) 
          ? prev.filter(d => d !== day)
          : [...prev, day].sort((a, b) => a - b)
      );
    };
    
    const handleAdd = () => {
      if (!text.trim() || !list || weekdays.length === 0) {
        alert('í• ì¼, ëª©ë¡, ìš”ì¼ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”');
        return;
      }
      
      const rec = {
        id: makeId("rec"),
        list,
        text: text.trim(),
        byweekday: weekdays,
        time: time || undefined,
        start: isYMD(startDate) ? startDate : todayYMD(),
        end: isYMD(endDate) ? endDate : undefined
      };
      
      setStore(p => ({
        ...p,
        recurring: [...(p.recurring || []), rec]
      }));
      
      // ì´ˆê¸°í™”
      setText('');
      setTime('');
      setWeekdays([]);
      setStartDate(todayYMD());
      setEndDate('');
      setRecurringModal(false);
      alert('ë°˜ë³µ í• ì¼ì´ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!');
    };
    
    return (
      <div style={S.modalOverlay} onClick={() => setRecurringModal(false)}>
        <div style={{...S.modalContent, maxWidth: 600}} onClick={(e) => e.stopPropagation()}>
          <h3 style={{ margin: '0 0 16px' }}>ë°˜ë³µ í• ì¼ ì¶”ê°€</h3>
          
          <div style={{ display: 'grid', gap: 16 }}>
            {/* ëª©ë¡ ì„ íƒ */}
            <div>
              <label style={S.label}>ëª©ë¡</label>
              <select
                value={list}
                onChange={(e) => setList(e.target.value)}
                style={S.textInput}
              >
                {store.lists.order.map(l => (
                  <option key={l} value={l}>{l}</option>
                ))}
              </select>
            </div>
            
            {/* í• ì¼ ì…ë ¥ */}
            <div>
              <label style={S.label}>í• ì¼</label>
              <input
                autoFocus
                placeholder="ì˜ˆ: ìš´ë™í•˜ê¸°"
                value={text}
                onChange={(e) => setText(e.target.value)}
                style={{ ...S.textInput, fontSize: 16 }}
              />
            </div>
            
            {/* ìš”ì¼ ì„ íƒ */}
            <div>
              <label style={S.label}>
                ë°˜ë³µ ìš”ì¼ ì„ íƒ ({weekdays.length}ê°œ ì„ íƒë¨)
              </label>
              <div style={{ display: 'flex', gap: 8, marginTop: 8 }}>
                {weekdayButtons.map(({ label, value }) => (
                  <button
                    key={value}
                    onClick={() => toggleWeekday(value)}
                    style={{
                      ...S.weekdayBtn,
                      ...(weekdays.includes(value) ? S.weekdayBtnActive : {})
                    }}
                  >
                    {label}
                  </button>
                ))}
              </div>
            </div>
            
            {/* ì‹œê°„ */}
            <div>
              <label style={S.label}>ì‹œê°„ (ì„ íƒì‚¬í•­)</label>
              <input
                type="time"
                value={time}
                onChange={(e) => setTime(e.target.value)}
                style={S.timeInput}
              />
            </div>
            
            {/* ê¸°ê°„ */}
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12 }}>
              <div>
                <label style={S.label}>ì‹œì‘ì¼</label>
                <input
                  type="date"
                  value={startDate}
                  onChange={(e) => setStartDate(e.target.value)}
                  style={S.dateInput}
                />
              </div>
              <div>
                <label style={S.label}>ì¢…ë£Œì¼ (ì„ íƒ, ë¹„ìš°ë©´ ë¬´ì œí•œ)</label>
                <input
                  type="date"
                  value={endDate}
                  onChange={(e) => setEndDate(e.target.value)}
                  style={S.dateInput}
                />
              </div>
            </div>
            
            {/* ë¯¸ë¦¬ë³´ê¸° */}
            {weekdays.length > 0 && (
              <div style={{
                padding: 12,
                background: '#f3f4f6',
                borderRadius: 8,
                fontSize: 13,
                color: '#374151'
              }}>
                <b>ë¯¸ë¦¬ë³´ê¸°:</b><br />
                ë§¤ì£¼ {weekdays.map(d => weekdayButtons[d].label).join(', ')}ìš”ì¼
                {time && ` ${time}`}ì—<br />
                "{text || '(í• ì¼ ì…ë ¥)'}" ìƒì„±
              </div>
            )}
            
            {/* ë²„íŠ¼ */}
            <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end', marginTop: 8 }}>
              <button onClick={() => setRecurringModal(false)} style={S.secondaryBtn}>
                ì·¨ì†Œ
              </button>
              <button onClick={handleAdd} style={S.primaryBtn}>
                ë°˜ë³µ ì¶”ê°€
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  /* ğŸ”¥ ë¡œê·¸ì¸ í™”ë©´ */
  const LoginScreen = () => (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 10000
    }}>
      <div style={{
        background: 'white',
        borderRadius: 24,
        padding: 48,
        maxWidth: 400,
        width: '90%',
        boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
        textAlign: 'center'
      }}>
        <div style={{
          width: 80,
          height: 80,
          margin: '0 auto 24px',
          background: 'linear-gradient(135deg, #3b82f6 0%, #1e40af 100%)',
          borderRadius: 20,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: 40
        }}>
          ğŸ“…
        </div>
        
        <h1 style={{ margin: '0 0 8px', fontSize: 28, color: '#111827' }}>
          Calendar Tasks
        </h1>
        <p style={{ margin: '0 0 32px', color: '#6b7280', fontSize: 15 }}>
          ëª¨ë“  ê¸°ê¸°ì—ì„œ ë™ê¸°í™”ë˜ëŠ”<br />í• ì¼ ê´€ë¦¬ ì•±
        </p>
        
        <button
          onClick={signInWithGoogle}
          style={{
            width: '100%',
            padding: '16px 24px',
            background: '#fff',
            border: '2px solid #e5e7eb',
            borderRadius: 12,
            fontSize: 16,
            fontWeight: 600,
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: 12,
            transition: 'all 0.2s'
          }}
          onMouseOver={(e) => e.currentTarget.style.transform = 'scale(1.02)'}
          onMouseOut={(e) => e.currentTarget.style.transform = 'scale(1)'}
        >
          <svg width="20" height="20" viewBox="0 0 24 24">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
        </button>
        
        <p style={{ marginTop: 24, fontSize: 13, color: '#9ca3af' }}>
          ë¡œê·¸ì¸í•˜ë©´ ëª¨ë“  ê¸°ê¸°ì—ì„œ<br />
          í• ì¼ì´ ìë™ìœ¼ë¡œ ë™ê¸°í™”ë¼ìš”
        </p>
      </div>
    </div>
  );

  /* UI */
  return (
    <>
      {/* ğŸ”¥ ë¡œê·¸ì¸ í•„ìš” ì‹œ ë¡œê·¸ì¸ í™”ë©´ */}
      {!authLoading && !user && <LoginScreen />}
      
      <QuickAddModal />
      <RecurringModal />
      <div style={S.app} className="app-grid">
      {/* === ìµœìƒë‹¨ í•œ ì¤„ êµí›ˆ ë°” === */}
    <div style={S.topNoteBar}>
      <div style={{ display:"flex", alignItems:"center", gap:10, width:"100%" }}>
        <div style={S.topNoteLabel}> </div>
        <input
          style={S.topNoteInput}
          placeholder="í•œ ì¤„ë¡œ í•µì‹¬ (ì˜ˆ: ì˜¤ëŠ˜ì€ ë¯¸ë£¨ê¸° ê¸ˆì§€)"
          value={store?.meta?.topNote || ""}
          onChange={(e)=>saveTopNote(e.target.value)}
        />
        {(store?.meta?.topNote || "").trim() && (
          <button
            style={S.smallBtn}
            onClick={()=>saveTopNote("")}
            title="ë¹„ìš°ê¸°"
          >
            ì§€ìš°ê¸°
          </button>
        )}
      </div>
    </div>
      {/* ì™¼ìª½: ë‹¬ë ¥ */}
      <div style={S.left}>
        <div style={S.leftHeader}>
          <div style={S.brand}>
            <span style={S.logoDot} /> 
            <b>Calendar Â· Tasks</b>
            
            {/* ğŸ”¥ ë™ê¸°í™” ìƒíƒœ í‘œì‹œ */}
            {user && (
              <div style={{
                marginLeft: 12,
                fontSize: 12,
                color: syncStatus === 'synced' ? '#22c55e' : syncStatus === 'syncing' ? '#f59e0b' : '#ef4444',
                display: 'flex',
                alignItems: 'center',
                gap: 4
              }}>
                {syncStatus === 'synced' && 'âœ“ ë™ê¸°í™”ë¨'}
                {syncStatus === 'syncing' && 'âŸ³ ë™ê¸°í™” ì¤‘...'}
                {syncStatus === 'offline' && 'âš  ì˜¤í”„ë¼ì¸'}
              </div>
            )}
          </div>
          <div style={{display:"flex",gap:8,alignItems:"center"}}>
           {/* ğŸ”¥ ì‚¬ìš©ì ì •ë³´ & ë¡œê·¸ì•„ì›ƒ */}
           {user && (
             <div style={{display:"flex",alignItems:"center",gap:8}}>
               <img 
                 src={user.photoURL} 
                 alt={user.displayName}
                 style={{width:32,height:32,borderRadius:'50%'}}
                 title={user.email}
               />
               <button onClick={signOutUser} style={{...S.ghostBtn,fontSize:12}}>
                 ë¡œê·¸ì•„ì›ƒ
               </button>
             </div>
           )}
           
           <button
             style={S.planToggleBtn}
             onClick={()=>{ setShowPlan(v=>!v); setShowTrash(false); setShowFailed(false); setShowDone(false); }}
             title={showPlan ? "ë‹¬ë ¥ ë³´ê¸°" : "ì¼ê³¼í‘œ ë³´ê¸°"}
           >
             {showPlan ? "ë‹¬ë ¥" : "ì¼ê³¼í‘œ"}
           </button>

            <button onClick={gotoPrevMonth} style={S.ghostBtn}>â—€</button>
            <div style={S.monthTitle}>{viewYear}ë…„ {viewMonth+1}ì›”</div>
            <button onClick={gotoNextMonth} style={S.ghostBtn}>â–¶</button>
          </div>
        </div>

         {showPlan ? (
           <PlanCanvas ymd={selectedDate} store={store} setStore={setStore} colorOf={colorOf}/>
         ) : (
           <>
             <div style={S.weekHead}>{weekdayNames.map(w=><div key={w} style={S.weekCell}>{w}</div>)}</div>
             <div style={S.grid}> 
  {grid.map((d, i)=> {
    const ymd = toYMD(d);

    const items = getDayPreview(ymd, showFailed); // âœ… ë³€ê²½
    const failCount = (store.dates[ymd]?.tasks?.[FAIL_LIST] || []).length; // âœ… ì¶”ê°€
    const failGlow = showFailed && failCount > 0; // âœ… ì¶”ê°€

    const over = Math.max(0, items.length - 5);
    const active = ymd === selectedDate;

    const baseStyle = {
      ...S.dayCell,
      ...(isTodayCell(d) ? S.dayToday : {}),
      ...(active ? S.dayActive : { opacity: isThisMonth(d) ? 1 : 0.6 }),
    };

    if (failGlow) {
      baseStyle.boxShadow = `${baseStyle.boxShadow}, 0 0 0 2px rgba(239,68,68,0.18), 0 0 22px rgba(239,68,68,0.22)`;
      baseStyle.border = "1px solid rgba(239,68,68,0.35)";
    }

    return (
      <button
        key={i}
        onClick={()=>selectDate(d)}
        onDoubleClick={()=>quickAddAt(ymd)}
        style={{ 
          ...S.dayCell,
          ...(isTodayCell(d)?S.dayToday:{}),
          ...(active?S.dayActive:{ opacity: isThisMonth(d)?1:0.6 })
        }}
        title={items.map(i2=>`${i2.list}: ${i2.text}${i2.done?" âœ“":""}`).join("\n")}
      >
        <div style={S.dayNum}>{d.getDate()}</div>
        <div style={S.pillsWrap}>
          {items.slice(0,5).map((it, j)=>(
            <div key={j} style={{
              ...S.pill, 
              background: it.deleted ? '#9ca3af' : colorOf(it.list), 
              opacity: (it.done || it.deleted) ? 0.5 : 1,
              textDecoration: (it.done || it.deleted) ? 'line-through' : 'none'
            }}>
              {it.done && 'âœ“ '}
              {it.deleted && 'âœ— '}
              {it.text}
            </div>
          ))}
          {over>0 && <div style={S.morePill}>+{over}</div>}
        </div>
      </button>
    );
  })}
</div>

           </>
         )}
      </div>


      {/* ì˜¤ë¥¸ìª½: ì¹´ë“œ/íˆ´ë°”/íŒ¨ë„ */}
      <div style={S.right}>
        <div style={S.toolbar}>
          <div style={{display:"flex",gap:8,flexWrap:"wrap"}}>
            <input
              placeholder="ìƒˆ ëª©ë¡ ì´ë¦„"
              value={newListName}
              onChange={(e)=>setNewListName(e.target.value)}
              onKeyDown={(e)=>e.key==="Enter" && addList()}
              style={S.listInput}
            />
            <button onClick={addList} style={S.primaryBtn}>ëª©ë¡ ë§Œë“¤ê¸°</button>

            {/* ë°˜ë³µ ì¶”ê°€ */}
            <button
              onClick={() => setRecurringModal(true)}
              style={S.secondaryBtn}
            >
              ë°˜ë³µ ì¶”ê°€
            </button>

            <button style={S.secondaryBtn} onClick={()=>setShowDone(v=>!v)}>{showDone?"ì‘ì—… ë³´ê¸°":"ì™„ë£Œ ë³´ê¸°"}</button>
            <button style={S.secondaryBtn} onClick={()=>setShowFailed(v=>!v)}>{showFailed?"ì‘ì—… ë³´ê¸°":"ëª»í•¨ ë³´ê¸°"}</button>
            <button style={S.secondaryBtn} onClick={()=>setShowTrash(v=>!v)}>{showTrash?"ì‘ì—… ë³´ê¸°":"íœ´ì§€í†µ ë³´ê¸°"}</button>
          </div>
        </div>

        {/* ë³¸ë¬¸ */}
         {showPlan ? (
         <PlanPanel
          ymd={selectedDate}
           store={store}
           setStore={setStore}
           colorOf={colorOf}
           lists={store.lists.order}
           saveDetails={saveDetails}
         />
 ) : !showTrash && !showFailed && !showDone ? (
          <div style={S.cards}>
            {store.lists.order.map((list)=>{
              const items=allByList[list]||[];
              const doneCnt=items.filter(t=>t.done).length;
              return (
                <div key={list} style={{...S.card, background: `linear-gradient(180deg, #ffffff 0%, #fafbff 100%)`, borderColor: colorOf(list) }}
                     onDragOver={onDragOver} onDrop={dropToList(list)}>
                  <div style={S.cardHead}>
                    <div style={{display:"flex",alignItems:"center",gap:10}}>
                      <div style={{...S.cardTag, background: colorOf(list)}} />
                      <div style={{fontWeight:800}}>{list}</div>
                      <input type="color" value={colorOf(list)} onChange={(e)=>setListColor(list,e.target.value)} style={S.colorPicker} title="ìƒ‰ ë³€ê²½"/>
                    </div>
                    <div style={{color:"#6b7280",fontSize:12}}>ì™„ë£Œ {doneCnt}/{items.length}</div>
                  </div>

                  {/* ì¶”ê°€ ì…ë ¥ */}
                  <div style={S.addRow}>
                    <input style={S.textInput} placeholder={`${list}ì— í•  ì¼ (ë‚ ì§œ ì—†ì–´ë„ ok)`}
                           value={inputs[list]?.text||""} onChange={(e)=>setInputFor(list,"text",e.target.value)}
                           onKeyDown={(e)=>e.key==="Enter" && addTaskGlobal(list)} />
                    <input type="date" style={S.dateInput}
                           value={inputs[list]?.date||""} onChange={(e)=>setInputFor(list,"date",e.target.value)}
                           onKeyDown={(e)=>e.key==="Enter" && addTaskGlobal(list)} />
                    <input type="time" style={S.timeInput}
                           value={inputs[list]?.time||""} onChange={(e)=>setInputFor(list,"time",e.target.value)}
                           onKeyDown={(e)=>e.key==="Enter" && addTaskGlobal(list)} />
                    <button style={S.primaryBtn} onClick={()=>addTaskGlobal(list)}>ì¶”ê°€</button>
                  </div>

                  {/* ì‘ì—… ë¦¬ìŠ¤íŠ¸ */}
                  <ul style={S.list}>
                    {items.map((t)=>(
                      <li key={t.id}
                          style={{...S.item, outline: t.date && parseYMD(t.date) < parseYMD(todayYMD()) && !t.done ? "1px solid #ef4444":"1px solid #e5e7eb"}}
                          draggable onDragStart={onDragStart({...t,_from:list})} onDragEnd={onDragEnd}
                          onDragOver={onDragOver} onDrop={dropBefore(list,t)}>
                        {/* ë©”ì¸ ì»¬ëŸ¼(ì œëª©+ë‚ ì§œ) */}
                        <div style={S.mainCol}>
                        <div
  style={{display:"flex",alignItems:"center",gap:10,flex:1,minWidth:0, cursor:"default"}}
  onClick={()=>setOpenTaskIds(p=>({...p,[t.id]:!p[t.id]}))}
>
  <input
    type="checkbox"
    checked={t.done}
    onClick={(e)=>e.stopPropagation()}
    onChange={()=>toggleDone(list,t.id,t.date)}
  />
  <button
    onClick={(e)=>{ e.stopPropagation(); toggleStar(list,t.id,t.date); }}
    style={S.starBtn}
    title="ì¤‘ìš”"
  >
    {t.star ? "â˜…" : "â˜†"}
  </button>
  <span
    style={{
      textDecoration: t.done ? "line-through" : "none",
      transition: "opacity .2s",
      opacity: t.done ? 0.6 : 1,
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }}
  >
    {t.text}
  </span>
</div>
                          <div style={S.dateLine}>
                            {t.date ?? "ë¯¸ì§€ì •"}{t.time ? ` ${t.time}` : ""}
                          </div>
                        </div>

                        {/* ìŠ¤í˜ì´ì„œ(2ì—´ ê³ ì •) */}
                        <div style={S.metaCol} />

                        {/* â‹¯/ì‚­ì œ */}
                        <div style={S.ctrlCol}>
                          <button
                            style={S.ghostBtn}
                            title="ìì„¸íˆ(ìš°ì„ /ë¯¸ë£¨ê¸°/ì•ŒëŒ/í•˜ìœ„ì¶”ê°€)"
                            onClick={()=>setOpenTaskIds(p=>({...p,[t.id]:!p[t.id]}))}
                          >
                            â‹¯
                          </button>
                          <button style={S.dangerBtn} onClick={()=>removeTask(list,t.id,t.date)}>ì‚­ì œ</button>
                        </div>

                        {/* [í•­ìƒ] ì„œë¸Œí…ŒìŠ¤í¬: ìˆìœ¼ë©´ ë³´ì´ê¸° */}
                        {(t.subtasks||[]).length > 0 && (
                          <ul style={S.subList}>
                            {(t.subtasks||[]).map(st=>(
                              <li key={st.id} style={S.subItem}>
                                <label style={{display:"flex",alignItems:"center",gap:8,flex:1,minWidth:0}}>
                                  <input type="checkbox" checked={st.done} onChange={()=>toggleSubtask(list,t.id,t.date,st.id)} />
                                  <input
                                    value={st.text}
                                    onChange={(e)=>editSubtaskText(list,t.id,t.date,st.id,e.target.value)}
                                    style={S.subTextInput}
                                  />
                                </label>
                                <button style={S.smallBtn} onClick={()=>removeSubtask(list,t.id,t.date,st.id)}>ì‚­ì œ</button>
                              </li>
                            ))}
                          </ul>
                        )}

                        {/* í¼ì¹¨ íŒ¨ë„: ìš°ì„ /ë¯¸ë£¨ê¸°/ì•ŒëŒ + í•˜ìœ„ì¶”ê°€ ì…ë ¥ë§Œ */}
                        {openTaskIds[t.id] && (
                          <div style={S.expandBox}>
                            <div style={S.expandRow}>
                              <label style={{display:"flex",alignItems:"center",gap:6}}>
                                ìš°ì„ 
                                <select
                                  value={t.priority||"mid"}
                                  onChange={(e)=>saveDetails(list,t.id,t.date,{priority:e.target.value})}
                                  style={S.priority}
                                >
                                  <option value="low">ë‚®ìŒ</option>
                                  <option value="mid">ë³´í†µ</option>
                                  <option value="high">ë†’ìŒ</option>
                                </select>
                              </label>

                              <div style={{display:"flex",gap:6,flexWrap:"wrap"}}>
                                <button style={S.smallBtn} onClick={()=>snoozeByDays(list,t.id,t.date,1)}>+1d</button>
                                <button style={S.smallBtn} onClick={()=>{
                                  const ds=prompt("ë©°ì¹ ì„ ë¯¸ë£¨ì‹œê² ìŠµë‹ˆê¹Œ?","1");
                                  const n=Number(ds||"0"); if(!Number.isFinite(n)||n===0) return;
                                  snoozeByDays(list,t.id,t.date,n);
                                }}>ì»¤ìŠ¤í…€ ë¯¸ë£¨ê¸°</button>
                                <button style={S.smallBtn} onClick={()=>{
                                  const hhmm = t.time || prompt("HH:MM","19:00") || "";
                                  scheduleAlarm(list,t.id,t.date?t.date:UND,t.date,hhmm);
                                }}>ğŸ”” ì•ŒëŒ</button>
                              </div>
                            </div>

                            <div style={{display:"flex",gap:6, marginTop:8, paddingLeft:18}}>
                              <input id={`sub_${t.id}`} placeholder="í•˜ìœ„ í• ì¼ ë‚´ìš©" style={S.subAddInput}
                                     onKeyDown={(e)=>{
                                       if(e.key==="Enter"){
                                         const val=e.currentTarget.value.trim(); if(!val) return;
                                         addSubtask(list,t.id,t.date,val);
                                         e.currentTarget.value="";
                                       }
                                     }}/>
                              <button style={S.secondaryBtn} onClick={()=>{
                                const inp = document.getElementById(`sub_${t.id}`);
                                const val = (inp?.value||"").trim(); if(!val) return;
                                addSubtask(list,t.id,t.date,val);
                                inp.value="";
                              }}>í•˜ìœ„ ì¶”ê°€</button>
                            </div>
                          </div>
                        )}
                      </li>
                    ))}
                    {items.length===0 && <li style={S.empty}>í•  ì¼ì´ ì—†ì–´</li>}
                  </ul>

                  <div style={{display:"flex",justifyContent:"flex-end",marginTop:10}}>
                    <button style={S.deleteBtn} onClick={()=>removeList(list)}>ëª©ë¡ ì‚­ì œ</button>
                  </div>
                </div>
              );
            })}
          </div>
        
        ) : showDone ? (
          /* ì™„ë£Œ íŒ¨ë„ */
          <div style={S.trashPanel}>
            <h3 style={{margin:0}}>ì™„ë£Œ</h3>
            <ul style={S.list}>
              {getAllDone().map(item=>(
                <li key={item.id} style={S.item}>
                  <div style={{display:"flex",flexDirection:"column",gap:6, minWidth:0}}>
                    <b style={{whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"}}>{item.task.text}</b>
                    <div style={{color:"#6b7280",fontSize:12}}>
                      ëª©ë¡: {item.list} Â· ë‚ ì§œ: {item.key===UND?"ë¯¸ì§€ì •":item.key}{item.task.time?` ${item.task.time}`:""}
                    </div>
                  </div>
                  <div style={S.ctrlCol}>
                    <button style={S.secondaryBtn} onClick={()=>markUndone(item.list, item.key, item.id)}>ë¯¸ì™„ë£Œë¡œ</button>
                    <button style={S.dangerBtn} onClick={()=>removeTask(item.list, item.id, item.key)}>ì‚­ì œ</button>
                  </div>
                </li>
              ))}
              {getAllDone().length===0 && <li style={S.empty}>ì™„ë£Œëœ í•­ëª© ì—†ìŒ</li>}
            </ul>
          </div>
        ) : showFailed ? (
          /* ëª»í•¨ íŒ¨ë„ */
          <div style={S.trashPanel}>
            <h3 style={{margin:0}}>ëª»í•¨</h3>
            <ul style={S.list}>
              {getAllFailed().map(item=>(
                <li key={item.id} style={S.item}>
                  <div style={{display:"flex",flexDirection:"column",gap:6, minWidth:0}}>
                    <b style={{whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"}}>{item.task.text}</b>
                    <div style={{color:"#6b7280",fontSize:12}}>
                      ë‚ ì§œ: {item.key===UND?"ë¯¸ì§€ì •":item.key}
                      {item.task.time?` ${item.task.time}`:""} Â· ë“±ë¡: {new Date(item.task.failedAt).toLocaleString()}
                    </div>
                  </div>
                  <div style={S.ctrlCol}>
                    <button style={S.secondaryBtn} onClick={()=>restoreFailed(item.key, item.id)}>ë‹¤ë¥¸ ëª©ë¡ìœ¼ë¡œ</button>
                    <button style={S.smallBtn} title="+1ì¼" onClick={()=>snoozeFailed(item.key, item.id, 1)}>+1d</button>
                    <button style={S.dangerBtn} onClick={()=>deleteFailed(item.key, item.id)}>ì‚­ì œ</button>
                  </div>
                </li>
              ))}
              {getAllFailed().length===0 && <li style={S.empty}>ëª»í•œ í•­ëª© ì—†ìŒ</li>}
            </ul>
          </div>
        ) : (
          /* íœ´ì§€í†µ íŒ¨ë„ */
          <div style={S.trashPanel}>
            <h3 style={{margin:0}}>íœ´ì§€í†µ</h3>
            <ul style={S.list}>
              {(store.trash||[]).map(tr=>(
                <li key={tr.id} style={S.item}>
                  <div style={{display:"flex",flexDirection:"column",gap:6, minWidth:0}}>
                    <b style={{whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis"}}>{tr.task.text}</b>
                    <div style={{color:"#6b7280",fontSize:12}}>ëª©ë¡: {tr.list} Â· ë‚ ì§œ: {tr.key===UND?"ë¯¸ì§€ì •":tr.key} Â· ì‚­ì œ: {new Date(tr.deletedAt).toLocaleString()}</div>
                  </div>
                  <div style={S.ctrlCol}>
                    <button style={S.secondaryBtn} onClick={()=>restoreTrash(tr.id)}>ë˜ëŒë¦¬ê¸°</button>
                    <button style={S.dangerBtn} onClick={()=>deleteForever(tr.id)}>ì™„ì „ì‚­ì œ</button>
                  </div>
                </li>
              ))}
              {(store.trash||[]).length===0 && <li style={S.empty}>íœ´ì§€í†µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</li>}
            </ul>
          </div>
        )}
      </div>
    </div>
    </>
  );

  /* ì™„ë£Œ/ëª»í•¨ í—¬í¼ */
  function getAllDone(){
    const out=[];
    for(const [key,obj] of Object.entries(store.dates||{})){
      for(const [list,arr] of Object.entries(obj.tasks||{})){
        if(list===FAIL_LIST) continue;
        for(const t of (arr||[])){
          if (t.done) out.push({ key, list, id:t.id, task:t });
        }
      }
    }
    return out;
  }
  function markUndone(list, key, id){
    updateTask(list, id, key || UND, t => ({ ...t, done:false, subtasks:(t.subtasks||[]).map(s=>({...s, done:false})) }));
  }

  function getAllFailed(){
    const out=[];
    for(const [key,obj] of Object.entries(store.dates||{})){
      const arr = obj.tasks?.[FAIL_LIST] || [];
      for(const t of arr) out.push({ key, id:t.id, task:t });
    }
    return out;
  }
  function restoreFailed(dateKey, taskId){
    const lists = store.lists.order;
    if(!lists.length) return alert("ëª©ë¡ì´ ì—†ìŠµë‹ˆë‹¤");
    const list = prompt(`ë³µêµ¬í•  ëª©ë¡?\n${lists.join(", ")}`, lists[0])?.trim();
    if(!list || !lists.includes(list)) return;
    const key = dateKey || UND;
    setStore(p=>{
      const d=p.dates[key]; if(!d) return p;
      const failed=(d.tasks[FAIL_LIST]||[]).slice();
      const idx=failed.findIndex(x=>x.id===taskId); if(idx<0) return p;
      const item={...failed[idx]}; failed.splice(idx,1);
      const arr=(d.tasks[list]||[]).slice(); delete item.failed; delete item.failedAt;
      arr.push(item);
      return {...p, dates:{...p.dates, [key]:{tasks:{...d.tasks, [FAIL_LIST]:failed, [list]:arr}}}};
    });
  }
  function deleteFailed(dateKey, taskId){
    const key=dateKey||UND;
    setStore(p=>{
      const d=p.dates[key]; if(!d) return p;
      const failed=(d.tasks[FAIL_LIST]||[]).filter(x=>x.id!==taskId);
      return {...p, dates:{...p.dates, [key]:{tasks:{...d.tasks, [FAIL_LIST]:failed}}}};
    });
  }
  function snoozeFailed(dateKey, taskId, days=1){
    const key=dateKey||UND;
    const dst = (()=>{ const base=parseYMD(key); base.setDate(base.getDate()+days); return toYMD(base); })();
    ensureKey(dst);
    setStore(p=>{
      const from=p.dates[key]; if(!from) return p;
      const arrF=(from.tasks[FAIL_LIST]||[]).slice();
      const idx=arrF.findIndex(t=>t.id===taskId); if(idx<0) return p;
      const item={...arrF[idx], deferCount:(arrF[idx].deferCount||0)+1};
      arrF.splice(idx,1);
      const to=p.dates[dst]??{tasks:{}}; const arrT=(to.tasks[FAIL_LIST]||[]).slice();
      arrT.push(item);
      return {...p, dates:{...p.dates, [key]:{tasks:{...from.tasks, [FAIL_LIST]:arrF}}, [dst]:{tasks:{...to.tasks, [FAIL_LIST]:arrT}}}};
    });
  }


  function getDayPreview(ymd, includeFailed = false) {
  const dd = store.dates[ymd];
  if (!dd) return [];

  return Object.entries(dd.tasks || {})
    .flatMap(([list, arr]) =>
      (arr || [])
        .filter(t => {
          if (list === FAIL_LIST) return includeFailed; // âœ… ëª»í•¨ì€ ì˜µì…˜ì¼ ë•Œë§Œ
          return true;
        })
        .map(t => ({
          text: t.text,
          list,
          done: t.done,
          deleted: t.deleted,
          failed: list === FAIL_LIST || !!t.failed, // âœ… í‘œì‹œìš© í”Œë˜ê·¸
        }))
    );
}
function PlanCanvas({ ymd, store, setStore, colorOf }){
  const d = parseYMD(ymd); const wd = d.getDay();

  const own = store.plan?.[ymd] || [];
  const rec = (store.planRecurring||[])
    .filter(r=>{
      const w=(r.byweekday||[]).map(Number).filter(Number.isFinite);
      if(!w.includes(wd)) return false;
      const okS=!r.start || parseYMD(r.start)<=d;
      const okE=!r.end   || parseYMD(r.end)>=d;
      return okS && okE;
    })
    .map(r=>({ id:`pr_${r.id}@${ymd}`, text:r.text, start:r.startTime, end:r.endTime, color:r.color||"#94a3b8", fromRecurring:r.id }));
  const blocks=[...rec, ...own];

  const removeBlock=(id)=> setStore(p=>{
    const arr=(p.plan?.[ymd]||[]).filter(b=>b.id!==id);
    return {...p, plan:{...(p.plan||{}), [ymd]:arr}};
  });

  return (
    <>
      <div style={{display:"flex",justifyContent:"space-between",alignItems:"center",margin:"0 0 8px"}}>
        <div style={{fontWeight:800}}>{ymd} ì¼ê³¼í‘œ</div>
      </div>
      <div style={S.planCanvas}>
        {[...Array(49)].map((_,i)=><div key={i} style={{position:"absolute",left:0,right:0,top:i*16,height:1,background:i%2===0?"#eef2ff":"#f8fafc"}}/>)}
        {[...Array(24)].map((_,h)=><div key={h} style={{position:"absolute",left:4,top:h*32-7,fontSize:11,color:"#64748b"}}>{pad(h)}:00</div>)}
        {blocks.map(b=>{
          if(!isHHMM(b.start)||!isHHMM(b.end)) return null;
          const sMin=(+b.start.slice(0,2))*60+(+b.start.slice(3));
          const eMin=(+b.end.slice(0,2))*60+(+b.end.slice(3));
          const top=Math.round(sMin/30)*16;
          const height=Math.max(16, Math.round((eMin-sMin)/30)*16);
          const color=b.list ? colorOf(b.list) : (b.color||"#94a3b8");
          return (
            <div key={b.id} style={{
              position:"absolute", left:70, right:8, top, height,
              border:`1px solid ${color}`, borderRadius:10, background:"#fff",
              boxShadow:"0 2px 8px rgba(0,0,0,.06)", display:"flex", alignItems:"center", gap:8, padding:"0 10px"
            }}>
              <div style={{width:10,height:10,borderRadius:5, background:color}}/>
              <div style={{fontWeight:700, overflow:"hidden", textOverflow:"ellipsis", whiteSpace:"nowrap"}}>{b.text}</div>
              <div style={{marginLeft:"auto", fontSize:12, color:"#64748b"}}>{b.start}~{b.end}</div>
              {!b.fromRecurring && <button style={S.smallBtn} onClick={()=>removeBlock(b.id)}>ì‚­ì œ</button>}
            </div>
          );
        })}
      </div>
    </>
  );
}
function PlanTaskRow({ t, ymd, addBlock, saveDetails, colorOf }) {
  const [start, setStart] = useState(t.time || "");
  const [dur, setDur] = useState(t.estimateMin || 60);

  return (
    <div style={{display:"grid",gridTemplateColumns:"1fr 100px 90px auto",gap:8,alignItems:"center"}}>
      <div style={{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}}>
        <span style={{fontWeight:700}}>{t.text}</span>{" "}
        <span style={{fontSize:12,color:"#64748b"}}>({t.list})</span>
      </div>

      <input type="time" value={start} onChange={e=>setStart(e.target.value)} style={S.timeInput}/>
      <input type="number" min={5} step={5} value={dur} onChange={e=>setDur(+e.target.value||0)} style={S.textInput}/>

      <button
        style={S.secondaryBtn}
        onClick={() => {
          if (!/^\d{2}:\d{2}$/.test(start)) return alert("HH:MM");
          const end = addMin(start, dur || 60);
          addBlock({ text: t.text, start, end, color: colorOf(t.list), list: t.list, fromTaskId: t.id });
          saveDetails(t.list, t.id, ymd, { time: start, estimateMin: dur || 60 });
        }}
      >
        ë°°ì¹˜
      </button>
    </div>
  );
}
function PlanPanel({ ymd, store, setStore, colorOf, lists, saveDetails }){
  const tasks = (()=> {
    const dd=store.dates[ymd]?.tasks || {};
    return Object.entries(dd)
      .filter(([list])=> list!==FAIL_LIST)
      .flatMap(([list,arr])=>(arr||[]).filter(t=>!t.done).map(t=>({...t,list})));
  })();

  const ensurePlanKey=(key)=> setStore(p=> p.plan?.[key]? p : ({...p, plan:{...(p.plan||{}), [key]:[]}}));
  const addBlock=(blk)=>{ ensurePlanKey(ymd); setStore(p=>{
    const arr=(p.plan?.[ymd]||[]).slice(); arr.push({id:makeId("blk"), ...blk});
    return {...p, plan:{...(p.plan||{}), [ymd]:arr}};
  });};

  const [newBlk,setNewBlk]=useState({text:"",start:"",end:"",color:"#111827"});
  const [recForm,setRecForm]=useState({text:"",days:"ì›”,í™”,ìˆ˜,ëª©,ê¸ˆ",startTime:"22:30",endTime:"06:30",color:"#334155",start:ymd,end:""});

  return (
    <div style={S.planRight}>
      <div style={{display:"grid",gap:10}}>
        <div style={{fontWeight:800}}>{ymd} í• ì¼ ë°°ì¹˜</div>

        <div style={{display:"grid",gap:8}}>
          {tasks.length===0 && <div style={S.empty}>ì˜¤ëŠ˜ í•  ì¼ì´ ì—†ì–´</div>}
          {tasks.map(t => (
            <PlanTaskRow
            key={t.id}
            t={t}
            ymd={ymd}
            addBlock={addBlock}
            saveDetails={saveDetails}
            colorOf={colorOf}
          />
        ))}
        </div>

        <hr/>

        <div style={{fontWeight:800}}>ìƒˆ ë¸”ë¡(ì¼ì •)</div>
        <div style={{display:"grid",gridTemplateColumns:"1fr 100px 100px 90px auto",gap:8}}>
          <input placeholder="ì œëª©" value={newBlk.text} onChange={e=>setNewBlk({...newBlk, text:e.target.value})} style={S.textInput}/>
          <input type="time" value={newBlk.start} onChange={e=>setNewBlk({...newBlk, start:e.target.value})} style={S.timeInput}/>
          <input type="time" value={newBlk.end} onChange={e=>setNewBlk({...newBlk, end:e.target.value})} style={S.timeInput}/>
          <input type="color" value={newBlk.color} onChange={e=>setNewBlk({...newBlk, color:e.target.value})} style={S.colorPicker}/>
          <button style={S.primaryBtn} onClick={()=>{
            const {text,start,end}=newBlk; if(!text.trim()||!isHHMM(start)||!isHHMM(end)) return alert("ì…ë ¥ í™•ì¸");
            addBlock({ text:text.trim(), start, end, color:newBlk.color }); setNewBlk({text:"",start:"",end:"",color:"#111827"});
          }}>ì¶”ê°€</button>
        </div>

        <hr/>

        <div style={{fontWeight:800}}>ë°˜ë³µ ë¸”ë¡(ìš”ì¼)</div>
        <div style={{display:"grid",gridTemplateColumns:"1fr 100px 100px 120px 120px 90px auto",gap:8}}>
          <input placeholder="ì˜ˆ: ìˆ˜ë©´" value={recForm.text} onChange={e=>setRecForm({...recForm, text:e.target.value})} style={S.textInput}/>
          <input type="time" value={recForm.startTime} onChange={e=>setRecForm({...recForm, startTime:e.target.value})} style={S.timeInput}/>
          <input type="time" value={recForm.endTime} onChange={e=>setRecForm({...recForm, endTime:e.target.value})} style={S.timeInput}/>
          <input placeholder="ìš”ì¼(ì›”,í™”â€¦)" value={recForm.days} onChange={e=>setRecForm({...recForm, days:e.target.value})} style={S.textInput}/>
          <input placeholder="ì‹œì‘ì¼" value={recForm.start} onChange={e=>setRecForm({...recForm, start:e.target.value})} style={S.textInput}/>
          <input placeholder="ì¢…ë£Œì¼(ì„ íƒ)" value={recForm.end} onChange={e=>setRecForm({...recForm, end:e.target.value})} style={S.textInput}/>
          <button style={S.secondaryBtn} onClick={()=>{
            const byweekday = recForm.days.replace(/\s/g,"").split(",").map(k=>WEEKDAY_MAP[k]).map(Number).filter(Number.isFinite);
            if(!recForm.text.trim()||!isHHMM(recForm.startTime)||!isHHMM(recForm.endTime)||byweekday.length===0) return alert("ì…ë ¥ í™•ì¸");
            const rec = { id: makeId("pRec"), text: recForm.text.trim(), byweekday, startTime: recForm.startTime, endTime: recForm.endTime,
                          start: isYMD(recForm.start)?recForm.start:todayYMD(), end: isYMD(recForm.end)?recForm.end:undefined, color: recForm.color };
            setStore(p=>({...p, planRecurring:[...(p.planRecurring||[]), rec]}));
            alert("ë°˜ë³µ ë¸”ë¡ ë“±ë¡ ì™„ë£Œ");
          }}>ë°˜ë³µ ì¶”ê°€</button>
        </div>
      </div>
    </div>
  );
}


}

/* ===== ìŠ¤íƒ€ì¼ ===== */
const S = {
  app:{ maxWidth:1600, margin:"24px auto", padding:16, display:"grid", gridTemplateColumns:"1fr 1fr", gap:18, fontFamily:"'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif", background:"linear-gradient(180deg,#f8fafc 0%,#f3f4f6 100%)" },
  left:{ border:"1px solid #e5e7eb", borderRadius:18, padding:14, background:"linear-gradient(180deg,#ffffff 0%,#f8fbff 100%)", boxShadow:"0 10px 30px rgba(30,64,175,0.06)" },
  leftHeader:{ display:"flex", justifyContent:"space-between", alignItems:"center", marginBottom:6 },
  brand:{ display:"flex", alignItems:"center", gap:8, color:"#1f2937" },
  logoDot:{ width:10, height:10, borderRadius:"50%", background:"#3b82f6", boxShadow:"0 0 0 6px rgba(59,130,246,.12)" },
  monthTitle:{ fontWeight:800, fontSize:18 },
  weekHead:{ display:"grid", gridTemplateColumns:"repeat(7, 1fr)", marginTop:6, color:"#6b7280", fontWeight:600 },
  weekCell:{ textAlign:"center", padding:"6px 0" },
  grid:{ marginTop:6, display:"grid", gridTemplateColumns:"repeat(7, 1fr)", gap:8 },
  dayCell:{ minHeight:110, borderRadius:14, border:"1px solid #e5e7eb", background:"#fff", display:"flex", flexDirection:"column", alignItems:"stretch", padding:8, gap:8, cursor:"pointer", textAlign:"left", transition:"transform .08s ease, box-shadow .12s ease", boxShadow:"0 2px 6px rgba(0,0,0,.03)" },
  dayToday:{ outline:"2px solid #2563eb22", boxShadow:"0 6px 14px rgba(37,99,235,.08)" },
  dayActive:{ transform:"scale(1.01)", boxShadow:"0 12px 28px rgba(0,0,0,.08)", border:"1px solid #94a3b8" },
  dayNum:{ fontWeight:800, color:"#111827" },
  pillsWrap:{ display:"grid", gap:6 },
  pill:{ fontSize:12, padding:"4px 6px", borderRadius:8, color:"#fff", whiteSpace:"nowrap", overflow:"hidden", textOverflow:"ellipsis" },
  morePill:{ fontSize:11, padding:"2px 6px", borderRadius:6, border:"1px dashed #94a3b8", color:"#64748b", background:"#fff" },

  right:{ display:"grid", gridTemplateRows:"auto 1fr", gap:12, minWidth:0 },
  toolbar:{ display:"flex", justifyContent:"space-between", alignItems:"center", gap:12, flexWrap:"wrap" },
  listInput:{ padding:"10px 12px", border:"1px solid #d1d5db", borderRadius:10, background:"#fff" },

  cards:{ display:"grid", gridTemplateColumns:"repeat(auto-fill, minmax(420px, 1fr))", gap:16, alignItems:"start" },
  card:{ border:"2px solid #e5e7eb", borderRadius:16, background:"#fff", padding:12, boxShadow:"0 16px 36px rgba(0,0,0,.06)", transition:"transform .08s ease, box-shadow .12s ease" },
  cardHead:{ display:"flex", alignItems:"baseline", justifyContent:"space-between", marginBottom:8 },
  cardTag:{ width:16, height:16, borderRadius:6, boxShadow:"0 0 0 6px rgba(0,0,0,.06)" },
  colorPicker:{ width:28, height:28, border:"1px solid #e5e7eb", borderRadius:8, background:"#fff", cursor:"pointer" },

  addRow:{ display:"grid", gridTemplateColumns:"1fr 140px 120px auto", gap:8, marginBottom:10 },
  textInput:{ padding:"10px 12px", borderRadius:10, border:"1px solid #d1d5db", minWidth:0, background:"#fff" },
  dateInput:{ padding:"10px 12px", borderRadius:10, border:"1px solid #d1d5db" },
  timeInput:{ padding:"10px 12px", borderRadius:10, border:"1px solid #d1d5db" },

  list:{ display:"grid", gap:8, listStyle:"none", padding:0, margin:0, minWidth:0 },

  /* ê° ì‘ì—… í–‰: ì œëª©(1ì—´) / ìŠ¤í˜ì´ì„œ(2ì—´) / ë²„íŠ¼(3ì—´) */
  item:{ display:"grid", gridTemplateColumns:"minmax(360px,1fr) auto auto", alignItems:"flex-start", gap:10, borderRadius:12, padding:"10px 12px", background:"#fff", boxShadow:"0 2px 6px rgba(0,0,0,.03)" },

  /* ì œëª©+ë‚ ì§œë¥¼ í•œ ì¹¸ì— ë¬¶ëŠ” ë˜í¼ (ì²« ì»¬ëŸ¼ ê³ ì •) */
  mainCol:{ gridColumn:"1 / 2", display:"grid", gap:2, minWidth:0 },

  /* ì œëª© ì•„ë˜ ë‚ ì§œ ë¼ì¸ */
  dateLine:{ fontSize:12, color:"#6b7280", marginLeft:28, marginTop:2, whiteSpace:"nowrap" },

  /* 2ì—´ ìŠ¤í˜ì´ì„œ */
  metaCol:{ display:"block", width:"auto" },

  /* ìš°ì¸¡ ë²„íŠ¼ë“¤ í•­ìƒ ìœ„ ê³ ì • */
  ctrlCol:{ display:"flex", alignItems:"center", gap:6, alignSelf:"start" },

  dateBadge:{ fontSize:12, padding:"2px 6px", borderRadius:8, background:"#eef2ff", color:"#111" },
  priority:{ fontSize:12, padding:"2px 4px", borderRadius:8, border:"1px solid #d1d5db", background:"#fff" },

  primaryBtn:{ padding:"10px 14px", borderRadius:10, border:"1px solid #111827", background:"#111827", color:"#fff", cursor:"pointer" },
  secondaryBtn:{ padding:"10px 12px", borderRadius:10, border:"1px solid #d1d5db", background:"#fff", cursor:"pointer" },
  ghostBtn:{ padding:"6px 10px", borderRadius:10, border:"1px solid #e5e7eb", background:"#fff", cursor:"pointer" },
  smallBtn:{ padding:"6px 8px", borderRadius:10, border:"1px solid #d1d5db", background:"#fff", cursor:"pointer" },
  dangerBtn:{ padding:"6px 10px", border:"1px solid #ef4444", background:"#ef4444", color:"#fff", cursor:"pointer" },
  deleteBtn:{ padding:"6px 10px", border:"1px solid #ef4444", background:"#fff", color:"#ef4444" },
  starBtn:{ border:"none", background:"transparent", cursor:"pointer", fontSize:16 },

  expandBox:{ gridColumn:"1 / -1", marginTop:8, padding:10, border:"1px dashed #d1d5db", borderRadius:10, background:"#fafafa" },
  expandRow:{ display:"flex", alignItems:"center", justifyContent:"space-between", gap:10, flexWrap:"wrap" },

  /* ì„œë¸Œí…ŒìŠ¤í¬ */
  subList:{ listStyle:"none", padding:0, marginTop:8 },
  subItem:{ display:"grid", gridTemplateColumns:"minmax(260px,1fr) auto", alignItems:"center", gap:8, marginTop:6, marginLeft:18, paddingLeft:12, borderLeft:"3px solid #e5e7eb" },
  subTextInput:{ flex:1, minWidth:0, width:"100%", padding:"8px 10px", border:"1px solid #d1d5db", borderRadius:8, background:"#fff" },
  subAddInput:{ flex:1, minWidth:0, width:"100%", padding:"8px 10px", border:"1px solid #d1d5db", borderRadius:8, background:"#fff" },

  trashPanel:{ border:"1px solid #e5e7eb", borderRadius:16, background:"#fff", padding:12, boxShadow:"0 10px 24px rgba(0,0,0,.06)" },

  empty:{ textAlign:"center", color:"#6b7280", padding:"16px 0", border:"1px dashed #e5e7eb", borderRadius:12, background:"#fafafa" },
   planWrap:{ display:"grid", gridTemplateColumns:"1fr 480px", gap:16, alignItems:"start" },
   planLeft:{ border:"1px solid #e5e7eb", borderRadius:16, background:"#fff", padding:12, boxShadow:"0 10px 24px rgba(0,0,0,.06)" },
   planRight:{ border:"1px solid #e5e7eb", borderRadius:16, background:"#fff", padding:12, boxShadow:"0 10px 24px rgba(0,0,0,.06)" },
   planToggleBtn:{ padding:"6px 10px", borderRadius:8, border:"1px solid #d1d5db", background:"#fff", cursor:"pointer", fontSize:12 },
   planCanvas:{
     position:"relative",
     height: 32*24,
     border:"1px solid #e5e7eb",
     borderRadius:12,
     background:"#f8fafc",
     overflow:"hidden",
     paddingLeft:80
   },
   topNoteBar:{
  gridColumn:"1 / -1",
  border:"1px solid #e5e7eb",
  borderRadius:14,
  padding:"10px 12px",
  background:"#ffffff",
  boxShadow:"0 6px 18px rgba(0,0,0,.04)",
  display:"flex",
  alignItems:"center",
  gap:10,
  marginBottom:8
},
topNoteLabel:{ fontWeight:800, fontSize:14, color:"#111827", whiteSpace:"nowrap" },
topNoteInput:{
  flex:1, minWidth:0,
  padding:"10px 12px",
  border:"1px solid #d1d5db",
  borderRadius:10,
  fontSize:14,
  background:"#f9fafb"
},

modalOverlay: {
  position: 'fixed',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  background: 'rgba(0, 0, 0, 0.5)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  zIndex: 1000,
  backdropFilter: 'blur(4px)'
},
modalContent: {
  background: '#fff',
  borderRadius: 16,
  padding: 24,
  maxWidth: 500,
  width: '90%',
  boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
  animation: 'modalFadeIn 0.2s ease-out'
},

label: {
  display: 'block',
  fontSize: 13,
  fontWeight: 600,
  color: '#374151',
  marginBottom: 6
},

toggleBtn: {
  padding: '8px 16px',
  borderRadius: 8,
  border: '2px solid #d1d5db',
  background: '#fff',
  color: '#6b7280',
  cursor: 'pointer',
  fontSize: 14,
  fontWeight: 600,
  transition: 'all 0.2s ease'
},

toggleBtnActive: {
  border: '2px solid #3b82f6',
  background: '#3b82f6',
  color: '#fff'
},

weekdayBtn: {
  flex: 1,
  padding: '12px 8px',
  borderRadius: 10,
  border: '2px solid #e5e7eb',
  background: '#fff',
  color: '#6b7280',
  cursor: 'pointer',
  fontSize: 15,
  fontWeight: 700,
  transition: 'all 0.2s ease',
  minWidth: 48
},

weekdayBtnActive: {
  border: '2px solid #3b82f6',
  background: '#eff6ff',
  color: '#3b82f6',
  transform: 'scale(1.05)'
},

};

/* ë°˜ì‘í˜• */
(function injectResponsive(){
  if (typeof document === "undefined") return;
  const css=`
    .app-grid { }
    @media (max-width: 1024px){
      .app-grid { grid-template-columns: 1fr !important; }
      .planWrap { grid-template-columns: 1fr !important; }
    }
    @keyframes modalFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
  `;
  const s=document.createElement("style"); s.innerHTML=css; document.head.appendChild(s);
})();